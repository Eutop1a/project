// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"helloworld/internal/data/question/model"
)

func newQuestionBase(db *gorm.DB, opts ...gen.DOOption) questionBase {
	_questionBase := questionBase{}

	_questionBase.questionBaseDo.UseDB(db, opts...)
	_questionBase.questionBaseDo.UseModel(&model.QuestionBase{})

	tableName := _questionBase.questionBaseDo.TableName()
	_questionBase.ALL = field.NewAsterisk(tableName)
	_questionBase.ID = field.NewInt64(tableName, "id")
	_questionBase.Type = field.NewString(tableName, "type")
	_questionBase.Content = field.NewString(tableName, "content")
	_questionBase.ImagePath = field.NewString(tableName, "image_path")
	_questionBase.Difficulty = field.NewFloat32(tableName, "difficulty")
	_questionBase.KnowledgeID = field.NewInt64(tableName, "knowledge_id")
	_questionBase.CreateTime = field.NewTime(tableName, "create_time")
	_questionBase.UpdatedAt = field.NewTime(tableName, "updated_at")
	_questionBase.DeletedAt = field.NewField(tableName, "deleted_at")

	_questionBase.fillFieldMap()

	return _questionBase
}

type questionBase struct {
	questionBaseDo

	ALL         field.Asterisk
	ID          field.Int64
	Type        field.String  // 题型（choice/fill/judge/essay）
	Content     field.String  // 题目文本内容
	ImagePath   field.String  // 图片存储路径
	Difficulty  field.Float32 // 难度系数（1-5）
	KnowledgeID field.Int64   // 关联知识点分类
	CreateTime  field.Time
	UpdatedAt   field.Time
	DeletedAt   field.Field

	fieldMap map[string]field.Expr
}

func (q questionBase) Table(newTableName string) *questionBase {
	q.questionBaseDo.UseTable(newTableName)
	return q.updateTableName(newTableName)
}

func (q questionBase) As(alias string) *questionBase {
	q.questionBaseDo.DO = *(q.questionBaseDo.As(alias).(*gen.DO))
	return q.updateTableName(alias)
}

func (q *questionBase) updateTableName(table string) *questionBase {
	q.ALL = field.NewAsterisk(table)
	q.ID = field.NewInt64(table, "id")
	q.Type = field.NewString(table, "type")
	q.Content = field.NewString(table, "content")
	q.ImagePath = field.NewString(table, "image_path")
	q.Difficulty = field.NewFloat32(table, "difficulty")
	q.KnowledgeID = field.NewInt64(table, "knowledge_id")
	q.CreateTime = field.NewTime(table, "create_time")
	q.UpdatedAt = field.NewTime(table, "updated_at")
	q.DeletedAt = field.NewField(table, "deleted_at")

	q.fillFieldMap()

	return q
}

func (q *questionBase) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := q.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (q *questionBase) fillFieldMap() {
	q.fieldMap = make(map[string]field.Expr, 9)
	q.fieldMap["id"] = q.ID
	q.fieldMap["type"] = q.Type
	q.fieldMap["content"] = q.Content
	q.fieldMap["image_path"] = q.ImagePath
	q.fieldMap["difficulty"] = q.Difficulty
	q.fieldMap["knowledge_id"] = q.KnowledgeID
	q.fieldMap["create_time"] = q.CreateTime
	q.fieldMap["updated_at"] = q.UpdatedAt
	q.fieldMap["deleted_at"] = q.DeletedAt
}

func (q questionBase) clone(db *gorm.DB) questionBase {
	q.questionBaseDo.ReplaceConnPool(db.Statement.ConnPool)
	return q
}

func (q questionBase) replaceDB(db *gorm.DB) questionBase {
	q.questionBaseDo.ReplaceDB(db)
	return q
}

type questionBaseDo struct{ gen.DO }

type IQuestionBaseDo interface {
	gen.SubQuery
	Debug() IQuestionBaseDo
	WithContext(ctx context.Context) IQuestionBaseDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IQuestionBaseDo
	WriteDB() IQuestionBaseDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IQuestionBaseDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IQuestionBaseDo
	Not(conds ...gen.Condition) IQuestionBaseDo
	Or(conds ...gen.Condition) IQuestionBaseDo
	Select(conds ...field.Expr) IQuestionBaseDo
	Where(conds ...gen.Condition) IQuestionBaseDo
	Order(conds ...field.Expr) IQuestionBaseDo
	Distinct(cols ...field.Expr) IQuestionBaseDo
	Omit(cols ...field.Expr) IQuestionBaseDo
	Join(table schema.Tabler, on ...field.Expr) IQuestionBaseDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IQuestionBaseDo
	RightJoin(table schema.Tabler, on ...field.Expr) IQuestionBaseDo
	Group(cols ...field.Expr) IQuestionBaseDo
	Having(conds ...gen.Condition) IQuestionBaseDo
	Limit(limit int) IQuestionBaseDo
	Offset(offset int) IQuestionBaseDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IQuestionBaseDo
	Unscoped() IQuestionBaseDo
	Create(values ...*model.QuestionBase) error
	CreateInBatches(values []*model.QuestionBase, batchSize int) error
	Save(values ...*model.QuestionBase) error
	First() (*model.QuestionBase, error)
	Take() (*model.QuestionBase, error)
	Last() (*model.QuestionBase, error)
	Find() ([]*model.QuestionBase, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.QuestionBase, err error)
	FindInBatches(result *[]*model.QuestionBase, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.QuestionBase) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IQuestionBaseDo
	Assign(attrs ...field.AssignExpr) IQuestionBaseDo
	Joins(fields ...field.RelationField) IQuestionBaseDo
	Preload(fields ...field.RelationField) IQuestionBaseDo
	FirstOrInit() (*model.QuestionBase, error)
	FirstOrCreate() (*model.QuestionBase, error)
	FindByPage(offset int, limit int) (result []*model.QuestionBase, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IQuestionBaseDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (q questionBaseDo) Debug() IQuestionBaseDo {
	return q.withDO(q.DO.Debug())
}

func (q questionBaseDo) WithContext(ctx context.Context) IQuestionBaseDo {
	return q.withDO(q.DO.WithContext(ctx))
}

func (q questionBaseDo) ReadDB() IQuestionBaseDo {
	return q.Clauses(dbresolver.Read)
}

func (q questionBaseDo) WriteDB() IQuestionBaseDo {
	return q.Clauses(dbresolver.Write)
}

func (q questionBaseDo) Session(config *gorm.Session) IQuestionBaseDo {
	return q.withDO(q.DO.Session(config))
}

func (q questionBaseDo) Clauses(conds ...clause.Expression) IQuestionBaseDo {
	return q.withDO(q.DO.Clauses(conds...))
}

func (q questionBaseDo) Returning(value interface{}, columns ...string) IQuestionBaseDo {
	return q.withDO(q.DO.Returning(value, columns...))
}

func (q questionBaseDo) Not(conds ...gen.Condition) IQuestionBaseDo {
	return q.withDO(q.DO.Not(conds...))
}

func (q questionBaseDo) Or(conds ...gen.Condition) IQuestionBaseDo {
	return q.withDO(q.DO.Or(conds...))
}

func (q questionBaseDo) Select(conds ...field.Expr) IQuestionBaseDo {
	return q.withDO(q.DO.Select(conds...))
}

func (q questionBaseDo) Where(conds ...gen.Condition) IQuestionBaseDo {
	return q.withDO(q.DO.Where(conds...))
}

func (q questionBaseDo) Order(conds ...field.Expr) IQuestionBaseDo {
	return q.withDO(q.DO.Order(conds...))
}

func (q questionBaseDo) Distinct(cols ...field.Expr) IQuestionBaseDo {
	return q.withDO(q.DO.Distinct(cols...))
}

func (q questionBaseDo) Omit(cols ...field.Expr) IQuestionBaseDo {
	return q.withDO(q.DO.Omit(cols...))
}

func (q questionBaseDo) Join(table schema.Tabler, on ...field.Expr) IQuestionBaseDo {
	return q.withDO(q.DO.Join(table, on...))
}

func (q questionBaseDo) LeftJoin(table schema.Tabler, on ...field.Expr) IQuestionBaseDo {
	return q.withDO(q.DO.LeftJoin(table, on...))
}

func (q questionBaseDo) RightJoin(table schema.Tabler, on ...field.Expr) IQuestionBaseDo {
	return q.withDO(q.DO.RightJoin(table, on...))
}

func (q questionBaseDo) Group(cols ...field.Expr) IQuestionBaseDo {
	return q.withDO(q.DO.Group(cols...))
}

func (q questionBaseDo) Having(conds ...gen.Condition) IQuestionBaseDo {
	return q.withDO(q.DO.Having(conds...))
}

func (q questionBaseDo) Limit(limit int) IQuestionBaseDo {
	return q.withDO(q.DO.Limit(limit))
}

func (q questionBaseDo) Offset(offset int) IQuestionBaseDo {
	return q.withDO(q.DO.Offset(offset))
}

func (q questionBaseDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IQuestionBaseDo {
	return q.withDO(q.DO.Scopes(funcs...))
}

func (q questionBaseDo) Unscoped() IQuestionBaseDo {
	return q.withDO(q.DO.Unscoped())
}

func (q questionBaseDo) Create(values ...*model.QuestionBase) error {
	if len(values) == 0 {
		return nil
	}
	return q.DO.Create(values)
}

func (q questionBaseDo) CreateInBatches(values []*model.QuestionBase, batchSize int) error {
	return q.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (q questionBaseDo) Save(values ...*model.QuestionBase) error {
	if len(values) == 0 {
		return nil
	}
	return q.DO.Save(values)
}

func (q questionBaseDo) First() (*model.QuestionBase, error) {
	if result, err := q.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.QuestionBase), nil
	}
}

func (q questionBaseDo) Take() (*model.QuestionBase, error) {
	if result, err := q.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.QuestionBase), nil
	}
}

func (q questionBaseDo) Last() (*model.QuestionBase, error) {
	if result, err := q.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.QuestionBase), nil
	}
}

func (q questionBaseDo) Find() ([]*model.QuestionBase, error) {
	result, err := q.DO.Find()
	return result.([]*model.QuestionBase), err
}

func (q questionBaseDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.QuestionBase, err error) {
	buf := make([]*model.QuestionBase, 0, batchSize)
	err = q.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (q questionBaseDo) FindInBatches(result *[]*model.QuestionBase, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return q.DO.FindInBatches(result, batchSize, fc)
}

func (q questionBaseDo) Attrs(attrs ...field.AssignExpr) IQuestionBaseDo {
	return q.withDO(q.DO.Attrs(attrs...))
}

func (q questionBaseDo) Assign(attrs ...field.AssignExpr) IQuestionBaseDo {
	return q.withDO(q.DO.Assign(attrs...))
}

func (q questionBaseDo) Joins(fields ...field.RelationField) IQuestionBaseDo {
	for _, _f := range fields {
		q = *q.withDO(q.DO.Joins(_f))
	}
	return &q
}

func (q questionBaseDo) Preload(fields ...field.RelationField) IQuestionBaseDo {
	for _, _f := range fields {
		q = *q.withDO(q.DO.Preload(_f))
	}
	return &q
}

func (q questionBaseDo) FirstOrInit() (*model.QuestionBase, error) {
	if result, err := q.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.QuestionBase), nil
	}
}

func (q questionBaseDo) FirstOrCreate() (*model.QuestionBase, error) {
	if result, err := q.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.QuestionBase), nil
	}
}

func (q questionBaseDo) FindByPage(offset int, limit int) (result []*model.QuestionBase, count int64, err error) {
	result, err = q.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = q.Offset(-1).Limit(-1).Count()
	return
}

func (q questionBaseDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = q.Count()
	if err != nil {
		return
	}

	err = q.Offset(offset).Limit(limit).Scan(result)
	return
}

func (q questionBaseDo) Scan(result interface{}) (err error) {
	return q.DO.Scan(result)
}

func (q questionBaseDo) Delete(models ...*model.QuestionBase) (result gen.ResultInfo, err error) {
	return q.DO.Delete(models)
}

func (q *questionBaseDo) withDO(do gen.Dao) *questionBaseDo {
	q.DO = *do.(*gen.DO)
	return q
}
