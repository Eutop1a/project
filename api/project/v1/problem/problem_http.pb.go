// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.8.4
// - protoc             v5.26.1
// source: project/v1/problem/problem.proto

package problemv1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationProblemCreateProblem = "/project.v1.problem.Problem/CreateProblem"
const OperationProblemDeleteProblem = "/project.v1.problem.Problem/DeleteProblem"
const OperationProblemGetProblemList = "/project.v1.problem.Problem/GetProblemList"
const OperationProblemUpdateProblem = "/project.v1.problem.Problem/UpdateProblem"

type ProblemHTTPServer interface {
	// CreateProblem 题目管理
	CreateProblem(context.Context, *CreateProblemReq) (*emptypb.Empty, error)
	DeleteProblem(context.Context, *DeleteProblemReq) (*emptypb.Empty, error)
	GetProblemList(context.Context, *GetProblemListReq) (*GetProblemListResp, error)
	UpdateProblem(context.Context, *UpdateProblemReq) (*emptypb.Empty, error)
}

func RegisterProblemHTTPServer(s *http.Server, srv ProblemHTTPServer) {
	r := s.Route("/")
	r.POST("/api/v1/problem", _Problem_CreateProblem0_HTTP_Handler(srv))
	r.DELETE("/api/v1/problem/{id}", _Problem_DeleteProblem0_HTTP_Handler(srv))
	r.PUT("/api/v1/problem/{id}", _Problem_UpdateProblem0_HTTP_Handler(srv))
	r.GET("/api/v1/problems", _Problem_GetProblemList0_HTTP_Handler(srv))
}

func _Problem_CreateProblem0_HTTP_Handler(srv ProblemHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateProblemReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationProblemCreateProblem)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateProblem(ctx, req.(*CreateProblemReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*emptypb.Empty)
		return ctx.Result(200, reply)
	}
}

func _Problem_DeleteProblem0_HTTP_Handler(srv ProblemHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteProblemReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationProblemDeleteProblem)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteProblem(ctx, req.(*DeleteProblemReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*emptypb.Empty)
		return ctx.Result(200, reply)
	}
}

func _Problem_UpdateProblem0_HTTP_Handler(srv ProblemHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateProblemReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationProblemUpdateProblem)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateProblem(ctx, req.(*UpdateProblemReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*emptypb.Empty)
		return ctx.Result(200, reply)
	}
}

func _Problem_GetProblemList0_HTTP_Handler(srv ProblemHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetProblemListReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationProblemGetProblemList)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetProblemList(ctx, req.(*GetProblemListReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetProblemListResp)
		return ctx.Result(200, reply)
	}
}

type ProblemHTTPClient interface {
	CreateProblem(ctx context.Context, req *CreateProblemReq, opts ...http.CallOption) (rsp *emptypb.Empty, err error)
	DeleteProblem(ctx context.Context, req *DeleteProblemReq, opts ...http.CallOption) (rsp *emptypb.Empty, err error)
	GetProblemList(ctx context.Context, req *GetProblemListReq, opts ...http.CallOption) (rsp *GetProblemListResp, err error)
	UpdateProblem(ctx context.Context, req *UpdateProblemReq, opts ...http.CallOption) (rsp *emptypb.Empty, err error)
}

type ProblemHTTPClientImpl struct {
	cc *http.Client
}

func NewProblemHTTPClient(client *http.Client) ProblemHTTPClient {
	return &ProblemHTTPClientImpl{client}
}

func (c *ProblemHTTPClientImpl) CreateProblem(ctx context.Context, in *CreateProblemReq, opts ...http.CallOption) (*emptypb.Empty, error) {
	var out emptypb.Empty
	pattern := "/api/v1/problem"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationProblemCreateProblem))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *ProblemHTTPClientImpl) DeleteProblem(ctx context.Context, in *DeleteProblemReq, opts ...http.CallOption) (*emptypb.Empty, error) {
	var out emptypb.Empty
	pattern := "/api/v1/problem/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationProblemDeleteProblem))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *ProblemHTTPClientImpl) GetProblemList(ctx context.Context, in *GetProblemListReq, opts ...http.CallOption) (*GetProblemListResp, error) {
	var out GetProblemListResp
	pattern := "/api/v1/problems"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationProblemGetProblemList))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *ProblemHTTPClientImpl) UpdateProblem(ctx context.Context, in *UpdateProblemReq, opts ...http.CallOption) (*emptypb.Empty, error) {
	var out emptypb.Empty
	pattern := "/api/v1/problem/{id}"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationProblemUpdateProblem))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
